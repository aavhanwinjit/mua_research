// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'message_key_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

MessageKeyModel _$MessageKeyModelFromJson(Map<String, dynamic> json) {
  return _MessageKeyModel.fromJson(json);
}

/// @nodoc
mixin _$MessageKeyModel {
  @JsonKey(name: "r")
  String? get requestUUID => throw _privateConstructorUsedError;
  @JsonKey(name: "sr")
  String? get serviceRequest => throw _privateConstructorUsedError;
  @JsonKey(name: "c")
  String? get channelId => throw _privateConstructorUsedError;
  @JsonKey(name: "j")
  String? get journeyId => throw _privateConstructorUsedError;
  @JsonKey(name: "s")
  String? get sessionId => throw _privateConstructorUsedError;
  @JsonKey(name: "i")
  String? get index => throw _privateConstructorUsedError;
  @JsonKey(name: "l")
  String? get languageId => throw _privateConstructorUsedError;
  @JsonKey(name: "t")
  String? get timestamp => throw _privateConstructorUsedError;
  @JsonKey(name: "ci")
  dynamic get ci => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageKeyModelCopyWith<MessageKeyModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageKeyModelCopyWith<$Res> {
  factory $MessageKeyModelCopyWith(
          MessageKeyModel value, $Res Function(MessageKeyModel) then) =
      _$MessageKeyModelCopyWithImpl<$Res, MessageKeyModel>;
  @useResult
  $Res call(
      {@JsonKey(name: "r") String? requestUUID,
      @JsonKey(name: "sr") String? serviceRequest,
      @JsonKey(name: "c") String? channelId,
      @JsonKey(name: "j") String? journeyId,
      @JsonKey(name: "s") String? sessionId,
      @JsonKey(name: "i") String? index,
      @JsonKey(name: "l") String? languageId,
      @JsonKey(name: "t") String? timestamp,
      @JsonKey(name: "ci") dynamic ci});
}

/// @nodoc
class _$MessageKeyModelCopyWithImpl<$Res, $Val extends MessageKeyModel>
    implements $MessageKeyModelCopyWith<$Res> {
  _$MessageKeyModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requestUUID = freezed,
    Object? serviceRequest = freezed,
    Object? channelId = freezed,
    Object? journeyId = freezed,
    Object? sessionId = freezed,
    Object? index = freezed,
    Object? languageId = freezed,
    Object? timestamp = freezed,
    Object? ci = freezed,
  }) {
    return _then(_value.copyWith(
      requestUUID: freezed == requestUUID
          ? _value.requestUUID
          : requestUUID // ignore: cast_nullable_to_non_nullable
              as String?,
      serviceRequest: freezed == serviceRequest
          ? _value.serviceRequest
          : serviceRequest // ignore: cast_nullable_to_non_nullable
              as String?,
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as String?,
      journeyId: freezed == journeyId
          ? _value.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      sessionId: freezed == sessionId
          ? _value.sessionId
          : sessionId // ignore: cast_nullable_to_non_nullable
              as String?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as String?,
      languageId: freezed == languageId
          ? _value.languageId
          : languageId // ignore: cast_nullable_to_non_nullable
              as String?,
      timestamp: freezed == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as String?,
      ci: freezed == ci
          ? _value.ci
          : ci // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageKeyModelImplCopyWith<$Res>
    implements $MessageKeyModelCopyWith<$Res> {
  factory _$$MessageKeyModelImplCopyWith(_$MessageKeyModelImpl value,
          $Res Function(_$MessageKeyModelImpl) then) =
      __$$MessageKeyModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "r") String? requestUUID,
      @JsonKey(name: "sr") String? serviceRequest,
      @JsonKey(name: "c") String? channelId,
      @JsonKey(name: "j") String? journeyId,
      @JsonKey(name: "s") String? sessionId,
      @JsonKey(name: "i") String? index,
      @JsonKey(name: "l") String? languageId,
      @JsonKey(name: "t") String? timestamp,
      @JsonKey(name: "ci") dynamic ci});
}

/// @nodoc
class __$$MessageKeyModelImplCopyWithImpl<$Res>
    extends _$MessageKeyModelCopyWithImpl<$Res, _$MessageKeyModelImpl>
    implements _$$MessageKeyModelImplCopyWith<$Res> {
  __$$MessageKeyModelImplCopyWithImpl(
      _$MessageKeyModelImpl _value, $Res Function(_$MessageKeyModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requestUUID = freezed,
    Object? serviceRequest = freezed,
    Object? channelId = freezed,
    Object? journeyId = freezed,
    Object? sessionId = freezed,
    Object? index = freezed,
    Object? languageId = freezed,
    Object? timestamp = freezed,
    Object? ci = freezed,
  }) {
    return _then(_$MessageKeyModelImpl(
      requestUUID: freezed == requestUUID
          ? _value.requestUUID
          : requestUUID // ignore: cast_nullable_to_non_nullable
              as String?,
      serviceRequest: freezed == serviceRequest
          ? _value.serviceRequest
          : serviceRequest // ignore: cast_nullable_to_non_nullable
              as String?,
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as String?,
      journeyId: freezed == journeyId
          ? _value.journeyId
          : journeyId // ignore: cast_nullable_to_non_nullable
              as String?,
      sessionId: freezed == sessionId
          ? _value.sessionId
          : sessionId // ignore: cast_nullable_to_non_nullable
              as String?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as String?,
      languageId: freezed == languageId
          ? _value.languageId
          : languageId // ignore: cast_nullable_to_non_nullable
              as String?,
      timestamp: freezed == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as String?,
      ci: freezed == ci
          ? _value.ci
          : ci // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageKeyModelImpl implements _MessageKeyModel {
  const _$MessageKeyModelImpl(
      {@JsonKey(name: "r") this.requestUUID,
      @JsonKey(name: "sr") this.serviceRequest,
      @JsonKey(name: "c") this.channelId,
      @JsonKey(name: "j") this.journeyId,
      @JsonKey(name: "s") this.sessionId,
      @JsonKey(name: "i") this.index,
      @JsonKey(name: "l") this.languageId,
      @JsonKey(name: "t") this.timestamp,
      @JsonKey(name: "ci") this.ci});

  factory _$MessageKeyModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageKeyModelImplFromJson(json);

  @override
  @JsonKey(name: "r")
  final String? requestUUID;
  @override
  @JsonKey(name: "sr")
  final String? serviceRequest;
  @override
  @JsonKey(name: "c")
  final String? channelId;
  @override
  @JsonKey(name: "j")
  final String? journeyId;
  @override
  @JsonKey(name: "s")
  final String? sessionId;
  @override
  @JsonKey(name: "i")
  final String? index;
  @override
  @JsonKey(name: "l")
  final String? languageId;
  @override
  @JsonKey(name: "t")
  final String? timestamp;
  @override
  @JsonKey(name: "ci")
  final dynamic ci;

  @override
  String toString() {
    return 'MessageKeyModel(requestUUID: $requestUUID, serviceRequest: $serviceRequest, channelId: $channelId, journeyId: $journeyId, sessionId: $sessionId, index: $index, languageId: $languageId, timestamp: $timestamp, ci: $ci)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageKeyModelImpl &&
            (identical(other.requestUUID, requestUUID) ||
                other.requestUUID == requestUUID) &&
            (identical(other.serviceRequest, serviceRequest) ||
                other.serviceRequest == serviceRequest) &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.journeyId, journeyId) ||
                other.journeyId == journeyId) &&
            (identical(other.sessionId, sessionId) ||
                other.sessionId == sessionId) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.languageId, languageId) ||
                other.languageId == languageId) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            const DeepCollectionEquality().equals(other.ci, ci));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      requestUUID,
      serviceRequest,
      channelId,
      journeyId,
      sessionId,
      index,
      languageId,
      timestamp,
      const DeepCollectionEquality().hash(ci));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageKeyModelImplCopyWith<_$MessageKeyModelImpl> get copyWith =>
      __$$MessageKeyModelImplCopyWithImpl<_$MessageKeyModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageKeyModelImplToJson(
      this,
    );
  }
}

abstract class _MessageKeyModel implements MessageKeyModel {
  const factory _MessageKeyModel(
      {@JsonKey(name: "r") final String? requestUUID,
      @JsonKey(name: "sr") final String? serviceRequest,
      @JsonKey(name: "c") final String? channelId,
      @JsonKey(name: "j") final String? journeyId,
      @JsonKey(name: "s") final String? sessionId,
      @JsonKey(name: "i") final String? index,
      @JsonKey(name: "l") final String? languageId,
      @JsonKey(name: "t") final String? timestamp,
      @JsonKey(name: "ci") final dynamic ci}) = _$MessageKeyModelImpl;

  factory _MessageKeyModel.fromJson(Map<String, dynamic> json) =
      _$MessageKeyModelImpl.fromJson;

  @override
  @JsonKey(name: "r")
  String? get requestUUID;
  @override
  @JsonKey(name: "sr")
  String? get serviceRequest;
  @override
  @JsonKey(name: "c")
  String? get channelId;
  @override
  @JsonKey(name: "j")
  String? get journeyId;
  @override
  @JsonKey(name: "s")
  String? get sessionId;
  @override
  @JsonKey(name: "i")
  String? get index;
  @override
  @JsonKey(name: "l")
  String? get languageId;
  @override
  @JsonKey(name: "t")
  String? get timestamp;
  @override
  @JsonKey(name: "ci")
  dynamic get ci;
  @override
  @JsonKey(ignore: true)
  _$$MessageKeyModelImplCopyWith<_$MessageKeyModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
